/* eslint-disable no-console */
/* Copyright Â© 2017 SAP SE or an affiliate company. All rights reserved.*/

'use strict';

const fs = require('fs');
const archiver = require('archiver');
const request = require('./request-utils');
const { v4: uuid } = require('uuid');
const path = require('path');
const fileType = require('file-type');
const xsenv = require('@sap/xsenv');
const log = require('cf-nodejs-logging-support');
const FormData = require('form-data');

exports.getDTRequestOptions = getDTRequestOptions;
exports.getUAAurl = getUAAurl;
exports.isZipFile = isZipFile;
exports.CDM_JSON = 'cdm.json';

exports.getService = function () {
  const exceptionString = 'Error loading environment';
  let html5AppsRepoServiceName;
  let services = xsenv.readServices();
  if (!services) {
    throw new Error(exceptionString + '. ' + 'no services bound');
  }
  try {
    html5AppsRepoServiceName = getHtml5AppsRepoServiceName(services);
  } catch (e) {
    throw new Error(exceptionString + '. ' + e);
  }
  return services[html5AppsRepoServiceName];
};

exports.getResourcesFolder = function (service) {
  let resourcesFolder = 'resources';
  service.tags.forEach(function (tag) {
    if (tag.indexOf('resources=') === 0) {
      resourcesFolder = tag.substring(10);
    }
  });
  return resourcesFolder;
};
exports.getCwd = function () {
  return process.env.PWD || process.cwd();
};

exports.validateResourcesFolder = function (resourcesFolder) {
  let cwd = exports.getCwd();
  let resourcesPath = path.join(cwd, resourcesFolder);
  if (!fs.existsSync(resourcesPath)) {
    throw Error('The resources folder ' + resourcesFolder + ' does not exist or is empty.');
  }
  if (!fs.lstatSync(resourcesPath).isDirectory()) {
    throw Error('The resources folder ' + resourcesFolder + ' is not a directory.');
  }
  let folderEntries = fs.readdirSync(resourcesPath);
  if (!folderEntries || !folderEntries.length) {
    throw Error('The resources folder ' + resourcesFolder + ' is empty.');
  }
  folderEntries.forEach(function (entry) {
    let entryPath = path.join(resourcesPath, entry);
    if (!fs.lstatSync(entryPath).isDirectory() && !isZipFile(entryPath) && entry !== exports.CDM_JSON) {
      throw Error('The resources folder is invalid because it contains the file - ' + entry +
        '; the resources folder should contain application folders and/or zip files.');
    }
  });
};

exports.validateService = function (service) {
  if (!service.credentials || !service.credentials.uri
    || !service.credentials.uaa || !service.credentials.uaa.url
    || !service.credentials.uaa.clientid ||
    (!service.credentials.uaa.clientsecret && !service.credentials.uaa.certificate)) {
    throw Error('Incomplete credentials for html5 applications repository service');
  }
};

exports.archiveFiles = function (appsZips, buildDirectory, buildFile, cdmFilePath) {
  return new Promise((resolve, reject) => {
    if (!fs.existsSync(buildDirectory)) {
      fs.mkdirSync(buildDirectory);
    }

    let output = fs.createWriteStream(buildFile);
    let archive = archiver('zip', {
      store: true
    });
    output.on('close', function () {
      // When archive finished - send it
      resolve();
    });
    archive.on('error', function (err) {
      reject(new Error('Archiving failed. ' + err));
    });
    archive.pipe(output);
    appsZips.forEach((appZip) => {
      let parts = appZip.split('/');
      let fileName = parts[parts.length - 1];
      archive.append(fs.createReadStream(appZip), {name: fileName});
    });
    if (cdmFilePath && fs.existsSync(cdmFilePath) && fs.lstatSync(cdmFilePath).isFile()) {
      archive.append(fs.createReadStream(cdmFilePath), {name: exports.CDM_JSON});
    }
    archive.finalize();
  });
};

exports.archive = function (zipResources, buildDirectory, buildFile, cb) {
  // Create build directory
  if (!fs.existsSync(buildDirectory)) {
    fs.mkdirSync(buildDirectory);
  }

  let output = fs.createWriteStream(buildFile);
  let archive = archiver('zip', {
    store: true
  });
  output.on('close', function () {
    // When archive finished - send it
    cb();
  });
  archive.on('error', function (err) {
    cb(new Error('Archiving failed. ' + err));
  });
  archive.pipe(output);
  archive.directory(zipResources, false);
  archive.finalize();
};

exports.upload = function (service, token, appsZips, cdmFile, cb) {
  let requestOptions = getDTRequestOptions(service, token);
  const formData = new FormData();
  appsZips.map(function (zipFile) {
    formData.append('apps',fs.createReadStream(zipFile));
  });
  if (fs.existsSync(cdmFile)) {
    formData.append('cdm', fs.createReadStream(cdmFile));
  }
  requestOptions.body = formData;
  requestOptions.maxContentLength = Infinity;
  requestOptions.maxBodyLength =  Infinity;
  request.put(requestOptions, function onResponse(err, res, body) {
    if (res && res.statusCode === 201) {
      cb();
    } else {
      let statusCode = res && res.statusCode;
      let logMessage = statusCode ? 'Error while uploading resources to Server' : 'Error in request';
      let responseMessage = statusCode ? `Error while uploading resources to Server; Status: ${statusCode}, Response: ${JSON.stringify(body)}` : `Error in request: ${err && err.message}`;
      log.logMessage('error', `In UploadFunction: ${logMessage}`);
      cb(new Error(responseMessage));
    }
  });
};

exports.isApplicationLogBound = function () {
  let applicationLogExist = false;
  let exceptionString = 'Error loading environment';
  let services = xsenv.readServices();
  if (!services || Object.keys(services).length === 0) {
    throw new Error(exceptionString + ' application logs');
  }

  for (let service in services) {
    if (services[service].label && services[service].label === 'application-logs') {
      applicationLogExist = true;
      break;
    }
  }
  return applicationLogExist;
};

function getUAAurl(service) {
  return service.credentials.uaa.url + '/oauth/token';
}

function getDTRequestOptions(service, token) {
  let corrID = uuid();
  let requestOptions = {
    url: service.credentials.uri + '/applications/content',
    headers: {
      'Authorization': 'Bearer ' + token,
      'X-CorrelationID': corrID
    },
  };
  return requestOptions;
}

function getHtml5AppsRepoServiceName(services) {
  if (!services) {
    throw new Error();
  }
  let serviceNames = {};

  for (let service in services) {
    if (services[service].tags) {
      services[service].tags.forEach(function (tag) {
        if (tag === 'html5-apps-repo-dt' || tag === 'html5-apps-repo') {
          serviceNames[service] = service;
        }
      });
    }
  }

  let namesLenght = Object.keys(serviceNames).length;

  if (namesLenght > 1) {
    throw new Error('Only one app-host service should be bound');
  }
  if (namesLenght === 0) {
    throw new Error('html5 applications repository service is not bound');
  }
  if (namesLenght === 1) {
    return Object.keys(serviceNames)[0];
  }
}

function isZipFile(filePath) {
  let type;
  if (!fs.existsSync(filePath) || fs.lstatSync(filePath).isDirectory()) { // if it's folder
    return false;
  }
  let buffer = Buffer.alloc(4100);
  let fd = fs.openSync(filePath, 'r');
  fs.readSync(fd, buffer, 0, 4100);
  type = fileType(buffer);
  return (type && type.ext === 'zip') ? true : false;
}

