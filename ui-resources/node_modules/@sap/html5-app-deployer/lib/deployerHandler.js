/* eslint-disable no-console */
/* Copyright Â© 2017 SAP SE or an affiliate company. All rights reserved.*/

'use strict';

const utils = require('./utils');
const fs = require('fs');
const async = require('async');
const path = require('path');
const http = require('http');
const log = require('cf-nodejs-logging-support');
const DestinationUtils = require('./destination-utils');
const GACDHandler = require('./gacd-handler');
const xssec = require('@sap/xssec');

exports.startDeployer = startDeployer;
exports.testDeployer = testDeployer;
exports.executeUpload = executeUpload;
exports.endProcess = endProcess;

function startDeployer() {
  start();
}

function testDeployer(cb) {
  start(cb);
}

function start(cb) {
  let service;
  let resourcesFolder;
  let loggingLevel = process.env.APP_LOG_LEVEL || 'info';
  // define logger
  log.setLoggingLevel(loggingLevel);
  try {
    if (!utils.isApplicationLogBound()) { // Defines readable logs if application log not bound
      log.setLogPattern('#{{written_at}}# - #{{level}}# {{msg}}');
    }
    log.logMessage('info', 'Application Deployer started ..', {'CODE': '2000'});
    // Get service
    service = utils.getService();
    // Validate service
    utils.validateService(service);
    // Get resources folder
    resourcesFolder = utils.getResourcesFolder(service);
    // validateResourcesFolder
    utils.validateResourcesFolder(resourcesFolder);
  } catch (e) {
    return endProcess(e,null, cb);
  }
  // executeUpload
  executeUpload(service, resourcesFolder, function (e) {
    let sapCloudService = process.env.SAP_CLOUD_SERVICE;
    if (!e && sapCloudService){
      let destinationUtils = new DestinationUtils(sapCloudService);
      destinationUtils.upsertDestinations((err,destinationLogs) => {
        endProcess(err,destinationLogs, cb);
      });
    } else {
      endProcess(e,null, cb);
    }
  });
}

function executeUpload(service, resourcesFolder, cb) {
  let appsZips = [];
  let cwd = utils.getCwd();
  let resourcesPath = path.join(cwd, resourcesFolder);
  let cdmFilePath = path.join(resourcesPath, utils.CDM_JSON);
  let buildDirectory = path.join(resourcesPath, '../deploymentTemp');
  let resourceFolderContents = fs.readdirSync(resourcesPath);

  // Remove cdm.json from folders list if exist
  resourceFolderContents = resourceFolderContents.filter(file => file !== 'cdm.json');

  let folderEntries = resourceFolderContents;
  // Get Token, Archive and Upload
  xssec.requests.requestClientCredentialsToken(null, service.credentials.uaa, null, null, (err, token) => {
    if (err) {
      return cb(err);
    }
    async.each(folderEntries,
      function (appDirName, iterateCb) { // for each entry
        let appResourcesPath = path.join(resourcesPath, appDirName);
        if (utils.isZipFile(appResourcesPath)) {
          appsZips.push(appResourcesPath);
          return iterateCb();
        } else {
          let applicationZip = path.join(buildDirectory, appDirName + '.zip');
          utils.archive(appResourcesPath, buildDirectory, applicationZip,
            function (err) {
              if (err) {
                return iterateCb(err);
              }
              log.logMessage('info', 'Archiver has been finalized and the output file ' + appDirName + '.zip descriptor has closed', {'code': '2001'});
              appsZips.push(applicationZip);
              iterateCb();
            });
        }
      }, function (err) { // after finish all entries
        if (err) {
          return cb(err);
        }
        let contentZipPath = path.join(buildDirectory, 'content.zip');
        let gacdHandler = new GACDHandler(service, token, contentZipPath);
        if (process.env.ASYNC_UPLOAD) {
          utils.archiveFiles(appsZips, buildDirectory, contentZipPath, cdmFilePath)
            .then(() => gacdHandler.upload())
            .then(() => gacdHandler.deploy())
            .then(() => {
              gacdHandler.pollDeployStatus();
              cb();
            })
            .catch((err) => {
              cb(err);
            });
        } else {
          utils.upload(service, token, appsZips, cdmFilePath, function (err) {
            cb(err);
          });
        }
      });
  });
}

function endProcess(err,destinationLogs, cb) {
  let server;
  let deployId = process.env.DEPLOY_ID || 'none';
  let isAsyncUpload = process.env.ASYNC_UPLOAD;
  let shouldExitProcess = process.env.EXIT_PROCESS_AFTER_UPLOAD === 'true';

  if (err) {
    console.log('Upload of html5 applications content failed ',err);
    if (err.message) {
      log.logMessage('error', '%s', err.message, {'CODE': '2004'});
    }
    log.logMessage('error', 'Application Deployer failed', {'CODE': '2005'});
    if (shouldExitProcess) {
      process.exit(1);
    }
  } else {
    console.log('Resources were successfully uploaded to Server');
    if (destinationLogs) {
      destinationLogs.forEach((log) => {
        if (log.iasDepAppName){
          console.log('Destination ' + log.name + ' created with ias dependency: ' + log.iasDepAppName);
        } else {
          console.log('Destination ' + log.name + ' succesfully created');
        }
      });
    }
    log.logMessage('info', 'Resources were successfully uploaded to Server', {'CODE': '2002'});
    log.logMessage('info', 'Application Deployer finished ..', {'CODE': '2003'});
    if (shouldExitProcess) {
      process.exit();
    }
  }

  if (deployId !== 'none' && !isAsyncUpload) { // Scenario of Deploy plugin
    if (err) {
      log.logMessage('error', 'Deployment of html5 application content failed [Deployment Id: %s]', deployId, {'CODE': '2007'});
      console.error('Deployment of html5 application content failed [Deployment Id: ' + deployId + '] ' + err);
    } else {
      log.logMessage('info', 'Deployment of html5 application content done [Deployment Id: %s]', deployId, {'CODE': '2006'});
      console.log('Deployment of html5 application content done [Deployment Id: ' + deployId + ']');
    }
    if (process.env.TEST_MODE){
      return cb(err);
    }
    setInterval(function () {
      log.logMessage('info', 'Waiting for deploy service to stop the application', {'CODE': '2008'});
    }, 30000);
  }
  else { // Scenario of pushing with manifest
    if (!err) { // don't leave app started if failed
      // For hanging the process
      if (process.env.TEST_MODE){
        return cb();
      }
      let port = process.env.PORT || 3000;
      // eslint-disable-next-line no-unused-vars
      server = http.createServer(function (req, res) {
      }).listen(port);
    } else {
      console.error('Upload of html5 applications content failed ');
    }
  }
  if (cb) {
    cb(err, server); // testing only
  }
}
